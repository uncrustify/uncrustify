<html>
<head>
   <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
   <title>Uncrustify: where do the Spaces options work</title>
</head>
<body lang="en-US">
<h1><a href="https://github.com/uncrustify/uncrustify">Uncrustify</a>:
Where do the options work?</h1>

<p>
</p>
<h2>Spaces</h2>
You want to "add/ force/ ignore/ remove" a
<ul>
  <li><a href="options_Space_Assign.html">space for assign</a></li>
  <li><a href="options_Space_Byref.html">space for byref</a></li>
  <li><a href="options_Space_Case.html">space for case</a></li>
  <li><a href="options_Space_Cast.html">space for cast</a></li>
  <li><a href="options_Space_Class.html">space for class</a></li>
  <li><a href="options_Space_Comma.html">space for comma</a></li>
  <li><a href="options_Space_D.html">space for D</a></li>
  <li><a href="options_Space_Enum.html">space for enum</a></li>
  <li><a href="options_Space_For.html">space for for loop</a></li>
  <li><a href="options_Space_New.html">space for new/ delete</a></li>
  <li><a href="options_Space_Operator.html">space for operator</a></li>
  <li><a href="options_Space_Paren.html">space for parenthesis</a></li>
  <li><a href="options_Preprocessor.html">space for preprocessor</a></li>
  <li><a href="options_Space_Template.html">space for template</a></li>
  <li><a href="options_Java.html">options_Java</a></li>
  <li><a href="options_Objectiv-C.html">options_Objectiv-C</a></li>
  <li><a href="options_C_sharp.html">options_C#</a></li>
  <li><a href="options_CLI_NET.html">options_CLI .NET</a></li>
  <li><a href="options_ASM.html">options_ASM</a></li>
</ul>
at some places.
<p>
</p>
Some more options...
<p>
</p>
<p> 
</p>
<table border="1", width="100%">
<tr>
<td>
<pre>
// Comments
<a title="sp_cmt_cpp_start"><strong><font color="red">  █</font></strong></a>
int a;            /* emb cmt */ int b;            // trailing cmt
<a title="sp_before_emb_cmt"><strong><font color="red">      █</a><a title="sp_num_before_tr_cmt">..........█                    █..........█</font></strong></a>

    union {
        uint maxChars;
        uint maxBytes;
    } mLength;
    union { int m_size; int m_any; };
    <a title="sp_inside_braces_struct"><strong><font color="red">       █                      █</font></strong></a>
    return { -1, -1, -1 };
    <a title="sp_inside_braces"><strong><font color="red">        █          █</font></strong></a>

class Parser :: ParserPrivate { };
<a title="sp_before_dc"><strong><font color="red">            █</a><a title="sp_after_dc">  █</a><a title="sp_inside_braces_empty">               █</font></strong></a>
template &lt;typename T&gt; class to { };
<a title="sp_inside_braces_empty"><strong><font color="red">                                █</font></strong></a>
my $all = { };
<a title="sp_inside_braces_empty"><strong><font color="red">           █</font></strong></a>
enum FocusEffect { };
<a title="sp_inside_braces_empty"><strong><font color="red">                  █</font></strong></a>
struct error { };
<a title="sp_inside_braces_empty"><strong><font color="red">              █</font></strong></a>
};

#define LOG_FMT (sev, args ...) \
<a title="sp_defined_paren"><strong><font color="red">               █</a><a title="sp_before_ellipsis">          █</font></strong></a>
   if (log_sev_on(sev)) { log_fmt(sev, ## args); }
   <a title="sp_pp_concat"><strong><font color="red">                                        █  </a><a title="sp_pp_concat">█</font></strong></a>
#endif
#define FS_NOCOW_FL 0x00800000
<a title="sp_macro"><strong><font color="red">                   █</font></strong></a>
#define STRHACK(x) HACKSTR(x)
<a title="sp_macro_func"><strong><font color="red">             █</font></strong></a>
#define wakeUpCaller(cond) \
<a title="sp_before_nl_cont"><strong><font color="red">                          █</font></strong></a>
    if (cond) { \
    <a title="sp_before_nl_cont"><strong><font color="red">           █</font></strong></a>
        cond->release(); \
        <a title="sp_before_nl_cont"><strong><font color="red">                █</font></strong></a>
     }
typedef struct { int val; int sel; } DiceInfo;
<a title="sp_brace_typedef"><strong><font color="red">                                    █</font></strong></a>
void * bar()
<a title="sp_before_ptr_star_func"><strong><font color="red">    █ </a><a title="sp_after_ptr_star_func">█</font></strong></a>
{
    int a = 5;
    <a title="sp_assign"><strong><font color="red">     █ █</font></strong></a>
    <a title="sp_before_assign"><strong><font color="red">     █ </a><a title="sp_after_assign">█</font></strong></a>
    int * const i;
    <a title="sp_after_ptr_star_qualifier"><strong><font color="red">     █</font></strong></a>
    c = a + b;
    <a title="sp_arith, sp_arith_additive"><strong><font color="red">     █ █</font></strong></a>
    a = ~ b;
    <a title="sp_inv"><strong><font color="red">     █</font></strong></a>
    x = - 5;
    <a title="sp_sign"><strong><font color="red">     █</font></strong></a>
    y = + 7;
    <a title="sp_sign"><strong><font color="red">     █</font></strong></a>
    (-- a);
    <a title="sp_incdec"><strong><font color="red">   █</font></strong></a>
    i ++;
    <a title="sp_incdec"><strong><font color="red"> █</font></strong></a>
    b = ( a == d ) ? 55 : 88;
    <a title="sp_cond_question"><strong><font color="red">              █ █</a><a title="sp_cond_colon">  █ █</font></strong></a>
    <a title="sp_cond_question_before"><strong><font color="red">              █</a><a title="sp_cond_question_after"> █</a><a title="sp_cond_colon_before">  █</a><a title="sp_cond_colon_after"> █</font></strong></a>
    b = ( a == d ) ? : 88;
    <a title="sp_cond_ternary_short"><strong><font color="red">                █</font></strong></a>
    if( ( a || b ) && c ) x = 1;
    <a title="sp_bool"><strong><font color="red">       █  █   █  █</font></strong></a>
    <a title="sp_inside_paren"><strong><font color="red">     █      █      █</font></strong></a>
    <a title="sp_paren_paren"><strong><font color="red">   █</font></strong></a>
    c = a > b;
    <a title="sp_compare"><strong><font color="red">     █ █</font></strong></a>
    int * i;
    <a title="sp_before_ptr_star"><strong><font color="red">   █ </a><a title="sp_after_ptr_star">█</font></strong></a>
    <a title="sp_before_unnamed_ptr_star"><strong><font color="red">   █</font></strong></a>
    int * * j;
    <a title="sp_between_ptr_star"><strong><font color="red">     █</font></strong></a>
    throw (x);
    <a title="sp_throw_paren"><strong><font color="red">     █</font></strong></a>
    try {
    <a title="sp_try_brace"><strong><font color="red">   █</font></strong></a>
    } catch (const Exception &e) { }
    <a title="sp_brace_catch"><strong><font color="red"> █</a><a title="sp_catch_paren">     █</font></strong></a>
    } catch (...) { }
    <a title="sp_brace_catch"><strong><font color="red"> █</a><a title="sp_catch_paren">     █</font></strong></a>
    } catch { }
    <a title="sp_brace_catch"><strong><font color="red"> █</a><a title="sp_catch_brace">     █</font></strong></a>
    auto x1 = decltype(x) {0};
    <a title="sp_after_decltype"><strong><font color="red">                     █</font></strong></a>
    Foo() noexcept () {}
    <a title="sp_after_noexcept"><strong><font color="red">              █</font></strong></a>
    void operator ++ ( );
    <a title="sp_after_operator"><strong><font color="red">             █</font></strong></a><a title="sp_after_operator_sym"><strong><font color="red">  █</font></strong></a><a title="sp_after_operator_sym_empty"><strong><font color="red"> █</font></strong></a>
    int a0[][] = { { 1 } };
    <a title="sp_after_type_brace_init_lst_open"><strong><font color="red">              █ █</font></strong></a><a title="sp_before_type_brace_init_lst_close"><strong><font color="red"> █ █</font></strong></a>
    char m_array [256];
    <a title="sp_before_vardef_square"><strong><font color="red">            █</font></strong></a>
    return { {crypt(_Nums, inSeed)} };
    <a title="sp_brace_brace"><strong><font color="red">        █                      █</font></strong></a>
    do {
    <a title="sp_do_brace_open"><strong><font color="red">  █</font></strong></a>
        xxx = _error;
    } while(0)
    <a title="sp_brace_close_while"><strong><font color="red"> █</font></strong></a>
    bool CompareGenomeByFeatureResults::clickOnLink(std::string const& inLink) {
        auto const [sequence, type, firstPosition, lastPosition] = parseLink(inLink);
    <a title="sp_cpp_before_struct_binding"><strong><font color="red">              █</font></strong></a>
    decltype (x)  y;
    <a title="sp_decltype_paren"><strong><font color="red">        █</font></strong></a>
    using x_t = decltype (x);
    <a title="sp_decltype_paren"><strong><font color="red">                    █</font></strong></a>
    foo( ABC );
    <a title="sp_func_call_user_inside_fparen"><strong><font color="red">    █   █</font></strong></a>
    foo( ( ABC ) )
    <a title="sp_func_call_user_paren_paren"><strong><font color="red">    █       █</font></strong></a>
    typedef void timer_cb (struct timer_node *n);
    <a title="sp_func_type_paren"><strong><font color="red">                     █</font></strong></a>
    if (n) ;
    <a title="sp_special_semi"><strong><font color="red">      █</font></strong></a>
    a( , 1);
    <a title="sp_paren_comma"><strong><font color="red">  █</font></strong></a>
    foo() noexcept;
    <a title="sp_paren_noexcept"><strong><font color="red">     █</font></strong></a>
    return {x};
    <a title="sp_return_brace"><strong><font color="red">      █</font></strong></a>
    void funcName() const;
    <a title="sp_paren_qualifier"><strong><font color="red">               █</font></strong></a>
    void ncName() override;
    <a title="sp_paren_qualifier"><strong><font color="red">             █</font></strong></a>
    template < int ... X > int bar2()
    <a title="sp_type_ellipsis"><strong><font color="red">              █</font></strong></a>
    {
            auto s = sizeof ... (  X  );
        <a title="sp_sizeof_ellipsis"><strong><font color="red">                   █</font></strong></a><a title="sp_sizeof_ellipsis_paren"><strong><font color="red">   █</font></strong></a>
            chomp(  X  ) ...;
        <a title="sp_paren_ellipsis"><strong><font color="red">                    █</font></strong></a>
            return X  +  ...;
    }
    do amime3(); while (false);
    <a title="sp_while_paren_open"><strong><font color="red">                  █</font></strong></a>
    auto b0 = unknown_kw { 2 };
    <a title="sp_word_brace_init_lst"><strong><font color="red">                    █</font></strong></a>
    if (data)   go = new ClassA();
    <a title="sp_skip_vbrace_tokens"><strong><font color="red">          █</font></strong></a>
    else        go = new ClassB();
    <a title="sp_skip_vbrace_tokens"><strong><font color="red">          █</font></strong></a>

    auto f0(int a, int b) -> int;
    <a title="sp_trailing_return"><strong><font color="red">                     █  █</font></strong></a>
</pre>
</td>
</tr>
</table>
<p></p>
<table border="1", width="100%">
<tr>
<td>

<pre>
int main(int argc , char *argv [])
<a title="sp_before_comma"><strong><font color="red">                 █</a><a title="sp_after_comma"> █</a><a title="sp_before_squares">          █</font></strong></a>
{
	int a [2];
	<a title="sp_before_square"><strong><font color="red">     █</font></strong></a>
	a[ n ] = 3;
	<a title="sp_inside_square"><strong><font color="red">  █ █</font></strong></a>
	const char *names [] =
	<a title="sp_before_squares"><strong><font color="red">                 █</font></strong></a>
	{
		"{ False , True }",
		<a title="sp_before_comma"><strong><font color="red">        █</a><a title="sp_after_comma"> █</font></strong></a>
		"{ Ignore, Add, Remove, Force }",

	return (-1);
	<a title="sp_return_paren"><strong><font color="red">      █</font></strong></a>


    int a ( );
    <a title="sp_func_proto_paren"><strong><font color="red">     █</a><a title="sp_inside_fparens"> █</font></strong></a>
    int a (int b) {};
    <a title="sp_func_def_paren"><strong><font color="red">     █</a><a title="sp_fparen_brace">       █</font></strong></a>
    int foo () {};
    <a title="sp_func_def_paren_empty"><strong><font color="red">       █</font></strong></a>
void ( int a ) ( int b );
<a title="sp_inside_tparen"><strong><font color="red">      █     █</a><a title="sp_after_tparen_close"> █</a><a title="sp_inside_fparen"> █     █</font></strong></a>
static void sockaddr_unmapped(
    struct sockaddr *sa __attribute__ ((unused)),
    <a title="sp_attribute_paren"><strong><font color="red">                                 █</font></strong></a>
    socklen_t *len __attribute__ ((unused)))
    <a title="sp_attribute_paren"><strong><font color="red">                            █</font></strong></a>

void (^ weak_recurseTreeNodes)(int a);
<a title="sp_after_ptr_block_caret"><strong><font color="red">       █</font></strong></a>
template< >
struct Bar< false > : Foo { };
<a title="sp_angle_colon"><strong><font color="red">                   █</font></strong></a>
</pre>
</td>
</tr>
</table>
<p>
</p>
<table border="1", width="100%">
<tr>
<td>

<pre>
template &lt; typename T &gt; inline static bool remove(T column)
<a title="sp_template_angle"><strong><font color="red">        █<a title="sp_inside_angle"> █<a title="sp_inside_angle">          █</font></strong></a>
<a title="sp_before_angle"><strong><font color="red">        █</a><a title="sp_after_angle">              █</font></strong></a>
</pre>

<pre>
int & a(int & b);
<a title="sp_before_byref_func"><strong><font color="red">   █</a><a title="sp_after_byref_func"> █</a><a title="sp_before_byref">     █</a><a title="sp_after_byref"> █</font></strong></a>
int c(int &)
<a title="sp_type_func"><strong><font color="red">   █</a><a title="sp_before_unnamed_byref">     █</font></strong></a>
{
	d = aa (& y,& d) ;
	<a title="sp_func_call_paren"><strong><font color="red">      █ </a><a title="sp_addr"> █   █</a><a title="sp_before_semi">  █</font></strong></a>
        e = ee ();
        <a title="sp_func_call_paren_empty"><strong><font color="red">      █</font></strong></a>
	if ( a == 5 ) ...
	<a title="sp_before_sparen"><strong><font color="red">  █</font></strong></a>
        <a title="sp_inside_sparen"><strong><font color="red">    █      █</font></strong></a>
        <a title="sp_inside_sparen_open"><strong><font color="red">    █</a><a title="sp_inside_sparen_close">      █</font></strong></a>
            ...
        if (b) ;
        <a title="sp_special_semi"><strong><font color="red">      █</font></strong></a>
	if ( a == 6 ) b = 66;        
        <a title="sp_after_sparen"><strong><font color="red">             █</font></strong></a>
	if ( a == 7 ) { b = 77; }        
        <a title="sp_sparen_brace"><strong><font color="red">             █</font></strong></a>
        if (! a) {
        <a title="sp_not"><strong><font color="red">     █</font></strong></a>
            b = 4;
        } else {
        <a title="sp_brace_else"><strong><font color="red"> █</a><a title="sp_else_brace">    █</font></strong></a>
            b = 5;
        }
        for(a = 1 ; a < b ; a++) {
        <a title="sp_before_semi_for"><strong><font color="red">         █</a><a title="sp_before_semi_for_empty">       █</font></strong></a>
           ...
	for( ; ; ) {
        <a title="sp_before_semi_for_empty"><strong><font color="red">    █ █</a><a title="sp_after_semi_for_empty"> █</font></strong></a>
           ...
	switch (whatIsToDo) ...
	<a title="sp_before_sparen"><strong><font color="red">      █</font></strong></a>
	while (start < end) ...
	<a title="sp_before_sparen"><strong><font color="red">     █</font></strong></a>

</pre>
</td>
</tr>
</table>
<p>
</p>
<table border="1", width="100%">
<tr>
<td>

<pre>
namespace Server {
<a title="sp_word_brace_ns"><strong><font color="red">                █</font></strong></a>
class Cache : public QObject
<a title="sp_before_class_colon"><strong><font color="red">           █</a><a title="sp_after_class_colon"> █</font></strong></a>
Cache::StorageDebugger ()
<a title="sp_func_class_paren"><strong><font color="red">                      █</font></strong></a>
    : mFile(0)
<a title="sp_before_constr_colon"><strong><font color="red">   █</a><a title="sp_after_constr_colon"> █</font></strong></a>
{
        new service;
        <a title="sp_after_new"><strong><font color="red">   █</font></strong></a>
        delete service;
        <a title="sp_after_new"><strong><font color="red">      █</font></strong></a>
        delete[] buffer;
        <a title="sp_after_new"><strong><font color="red">        █</font></strong></a>
        if (this == & other) return * this;
        <a title="sp_addr"><strong><font color="red">             █</a><a title="sp_deref">               █</font></strong></a>
        switch (a) {
        case 1 :
        <a title="sp_before_case_colon"><strong><font color="red">      █</font></strong></a>
                b= 1;
                break;
        case 2 : {
                b = 2;
                break;
        }
        default :
                break;
        }
        bool operator () (Entity::Id lhs, Entity::Id rhs) const
        ...<a title="sp_after_operator"><strong><font color="red">          █</a><a title="sp_after_operator_sym">  █</font></strong></a>

        a = ( int ) 5.6;
        <a title="sp_inside_paren_cast"><strong><font color="red">     █   █</a><a title="sp_after_cast"> █</font></strong></a>
        cpp = int (7);
        <a title="sp_cpp_cast_paren"><strong><font color="red">         █</font></strong></a>
        len = sizeof (int);
        <a title="sp_sizeof_paren"><strong><font color="red">            █</font></strong></a>
        SomeStruct a = SomeStruct {1, 2, 3};
        <a title="sp_word_brace_init_lst"><strong><font color="red">                         █</font></strong></a>
	someFuncCall(SomeStruct {4, 5, 6});
	<a title="sp_word_brace_init_lst"><strong><font color="red">                       █</font></strong></a>
        log . foo . bar = 5;
        <a title="sp_member"><strong><font color="red">   █ █   █ █</font></strong></a>
	other -> foo -> bar = 123;
	<a title="sp_member"><strong><font color="red">     █  █   █  █</font></strong></a>
}
/// doxygen sequence
<a title="sp_cmt_cpp_doxygen"><strong><font color="red">   █</font></strong></a>
///< doxygen sequence
<a title="sp_cmt_cpp_doxygen"><strong><font color="red">    █</font></strong></a>
//! doxygen sequence
<a title="sp_cmt_cpp_doxygen"><strong><font color="red">   █</font></strong></a>
//!< doxygen sequence
<a title="sp_cmt_cpp_doxygen"><strong><font color="red">    █</font></strong></a>
#if A
#else /* Comment A */
<a title="sp_endif_cmt"><strong><font color="red">     █</font></strong></a>
#endif /* Comment B */
<a title="sp_endif_cmt"><strong><font color="red">      █</font></strong></a>
</pre>
</td>
</tr>
</table>
<table border="1", width="100%">
<tr>
<td>

<pre>
void Initialize( BYTE nDelay = 100 );
<a title="sp_assign_default"><strong><font color="red">                            █ █</font></strong></a>
void f1()
{
      auto a = [<a title="sp_inside_square"><font color="red">█</font></a>=<a title="sp_inside_square"><font color="red">█</font></a>]<a title="sp_cpp_lambda_square_paren"><font color="red">█</font></a>(<a title="sp_cpp_lambda_argument_list"><font color="red">█</font></a>int *a, Something & b<a title="sp_cpp_lambda_argument_list"><font color="red">█</font></a>);

      parallel_for(0, 100, [<a title="sp_inside_square"><font color="red">█</font></a>&<a title="sp_inside_square"><font color="red">█</font></a>]<a title="sp_cpp_lambda_square_paren"><font color="red">█</font></a>(<a title="sp_cpp_lambda_argument_list"><font color="red">█</font></a>const int i<a title="sp_cpp_lambda_argument_list"><font color="red">█</font></a>)<a title="sp_cpp_lambda_paren_brace"><font color="red">█</font></a>{
          const std::vector<int> values = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13 };

      list[idx] (param);
      <a title="sp_square_fparen"><font color="red">         █</font></a>

double foo()
{
	return( foo(n) );
	<a title="sp_balance_nested_parens"><strong><font color="red">       █      █</font></strong></a>


Vector2&lt;double&gt; ()
<a title="sp_angle_paren"><strong><font color="red">               █</font></strong></a>

{
        List&lt;byte&gt; bob = new List&lt;byte&gt; ();
        <a title="sp_angle_word"><strong><font color="red">          █</font></strong></a>
        QVector&lt;QPair&lt;Condition, QString&gt; &gt; mWhenThen;
        <a title="sp_permit_cpp11_shift"><strong><font color="red">                                 █</font></strong></a>

template&lt;int i, int ... Indexes, typename IdxHolder, typename ... Elements&gt;
<a title="sp_before_ellipsis"><strong><font color="red">                   █                                         █</font></strong></a>
struct index_holder_impl&lt;i, index_holder&lt;Indexes ...&gt;, IdxHolder, Elements ...&gt;
<a title="sp_before_ellipsis"><strong><font color="red">                                                █                         █</font></strong></a>
{
	typedef typename index_holder_impl&lt;i + 1, index_holder&lt;Indexes ... i&gt;,	Elements ...&gt;::type type;
	<a title="sp_before_ellipsis"><strong><font color="red">                                                              █                 █</font></strong></a>
</pre>
</td>
</tr>
</table>
<table border="1", width="100%">Java Sources
<tr>
<td>
<pre>

    for (Type var : expr)
    <a title="sp_after_for_colon"><strong><font color="red">               █</font></strong></a>

</pre>
</td>
</tr>
</table>
</body>
</html>
