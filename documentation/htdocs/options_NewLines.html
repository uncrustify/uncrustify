<html>
<head>
   <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
   <title>Uncrustify: where do the New Lines options work</title>
</head>
<body lang="en-US">
<h1><a href="https://github.com/uncrustify/uncrustify">Uncrustify</a>:
Where do the options work?</h1>
<h2>New lines</h2>
<p>
</p>
<hr>
<pre>
<a title="nl_remove_extra_newlines"><strong><font color="red">█</font></strong></a>
<a title="nl_start_of_file"><strong><font color="red"><strong><font color="red">█</font></strong></font></strong></a>
void bar_0();  // function definition
<a title="nl_func_paren"><strong><font color="red">          █</a><a title="nl_func_def_empty">█</font></strong></a>
void bar_0()   // function declaration
<a title="nl_func_def_paren"><strong><font color="red">          █</a><a title="nl_func_decl_empty">█</font></strong></a>
void A::bar_1(int a);
<a title="nl_func_scope_name"><strong><font color="red">        █</a><a title="nl_func_def_start">    █</a><a title="nl_func_def_end_single">     █</font></strong></a>
void bar_2(int a) <a title="nl_fdef_brace"><strong><font color="red">█</font></strong></a>
<a title="nl_func_type_name"><strong><font color="red">    █</a><a title="nl_func_decl_start">     █</a><a title="nl_func_decl_end">     █</font></strong></a>
<a title="nl_func_decl_start_single"><strong><font color="red">          █</a><a title="nl_func_decl_end_single">     █</font></strong></a>
{<a title="nl_collapse_empty_body"><strong><font color="red">█</font></strong></a>
}
<a title="nl_after_func_body"><strong><font color="red">█</font></strong></a>
void bar_3(int x,
           int y)
<a title="nl_func_def_args"><strong><font color="red">          █</a><a title="nl_func_decl_end">    █</font></strong></a>
{
    int a = 5;<a title="nl_after_semicolon"><strong><font color="red"> █</font></strong></a>
    int b = 7;
    <a title="nl_var_def_blk_end_func_top"><strong><font color="red">    █</font></strong></a>
    a = 135;
    list_for_each(item, list) {
<a title="nl_fcall_brace"><strong><font color="red">                             █</font></strong></a>
    }
<a title="nl_before_block_comment"><strong><font color="red">    █</font></strong></a>
    /* c1
     * c2
     */
<a title="nl_max"><strong><font color="red">    █</font></strong></a>
    int x2;
<a title="nl_before_c_comment"><strong><font color="red">    █</font></strong></a>
    /* single comment */
<a title="nl_before_cpp_comment"><strong><font color="red">    █</font></strong></a>
    // cpp comment
    std::for_each(a, b, [] (int& b) -> foo {
<a title="nl_cpp_ldef_brace"><strong><font color="red">                                            █</font></strong></a>
        b+=3;
    }
    A_function(parameter_for_A);
<a title="nl_func_call_start"><strong><font color="red">              █</font></strong></a><a title="nl_func_call_end"><strong><font color="red">               █</font></strong></a>
}
<a title="nl_end_of_file"><strong><font color="red">█</font></strong></a>
<hr>
class foo : public my_Class<a title="nl_class_brace"><strong><font color="red"> █</font></strong></a>
<a title="nl_class_colon"><strong><font color="red">         █</font></strong></a>
{
    void bar_c(int t, int u)<a title="nl_constr_colon"><strong><font color="red"> █</font></strong></a>
<a title="nl_func_type_name_class, nl_func_proto_type_name"><strong><font color="red">        █</a><a title="nl_func_decl_args">            █</font></strong></a>
        : t(222)
        , u(88)
<a title="nl_constr_init_args, pos_constr_comma"><strong><font color="red">        █</font></strong></a>
    {
<a title="nl_typedef_blk_start"><strong><font color="red">        █</font></strong></a>
        typedef char CHAR;
<a title="nl_typedef_blk_end"><strong><font color="red">        █</a><a title="nl_var_def_blk_start"> █</font></strong></a>
        CHAR c;
        int a;
        int b;
<a title="nl_var_def_blk_end"><strong><font color="red">        █</font></strong></a>
        c = 'a';
<a title="nl_before_switch"><strong><font color="red">        █</font></strong></a>
        switch (a) {
<a title="nl_switch_brace"><strong><font color="red">                  █</font></strong></a>
        case 0:
            b = 1;
            break;
<a title="nl_before_case"><strong><font color="red">        █</font></strong></a>
        case 1: b = 5; break;
<a title="nl_after_case"><strong><font color="red">               █</font></strong></a>
        case 13: {
<a title="nl_case_colon_brace"><strong><font color="red">                █</font></strong></a>
            b = 15;
            break;
        }
        }
<a title="nl_after_switch"><strong><font color="red">        █</a><a title="nl_before_do"> █</font></strong></a>
        do { <a title="nl_do_brace"><strong><font color="red">█</font></strong></a>
           do_something();
        } while (!d.isEmpty());
<a title="nl_brace_while"><strong><font color="red">        █</a><a title="nl_after_do">█</a><a title="nl_before_if"> █</font></strong></a>
        if (a) { <a title="nl_if_brace"><strong><font color="red">█</font></strong></a>
            b = 1;
        } else if (c) {
<a title="nl_brace_else"><strong><font color="red">         █</a><a title="nl_else_if">    █</a><a title="nl_elseif_brace">      █</font></strong></a>
            b ;
        } else {
<a title="nl_else_brace"><strong><font color="red">              █</font></strong></a>
            b = 3;
        }
<a title="nl_after_if"><strong><font color="red">        █</a><a title="nl_before_for"> █</font></strong></a>
        for (a = 1; a < 5; a++) {
<a title="nl_for_brace"><strong><font color="red">                              █</font></strong></a>
            b = b + a;
        }
<a title="nl_after_for"><strong><font color="red">        █</font></strong></a>
        for (int a = 1; a < 5;
             a++) {
<a title="nl_multi_line_cond"><strong><font color="red">                 █</font></strong></a>
            b = a + 4;
        }
        try {
<a title="nl_try_brace"><strong><font color="red">        █</font></strong></a>
            b = 1;
            if (err) {
<a title="nl_before_throw"><strong><font color="red">                █</font></strong></a>
                throw std::runtime_error(std::string("nextKey: ") + err.asString());
            }
        } catch (const std::exception &exc) {
<a title="nl_brace_catch"><strong><font color="red">         █</a><a title="nl_catch_brace">                                 █</font></strong></a>
            b = 3;
        }
<a title="nl_before_while"><strong><font color="red">        █</font></strong></a>
        while (c) {
<a title="nl_while_brace"><strong><font color="red">             █</font></strong></a>
            b ;
        }
<a title="nl_after_while"><strong><font color="red">        █</font></strong></a>
    }
    enum CaseOfOne {
<a title="nl_enum_brace"><strong><font color="red">                  █</font></strong></a>
        a1,
        b1,
<a title="nl_ds_struct_enum_cmt"><strong><font color="red">        █</font></strong></a>
        // comment
        c1,
<a title="nl_ds_struct_enum_close_brace"><strong><font color="red">        █</font></strong></a>
    };
    struct indent_ptr_t <a title="nl_struct_brace"><strong><font color="red">█</font></strong></a>
   {
        Chunk *ref;
<a title="nl_ds_struct_enum_cmt"><strong><font color="red">        █</font></strong></a>
        // comment
        int delta;
<a title="nl_ds_struct_enum_close_brace"><strong><font color="red">        █</font></strong></a>
    } ipt;
<a title="nl_brace_struct_var"><strong><font color="red">     █</font></strong></a>
<a title="nl_after_struct"><strong><font color="red">    █</font></strong></a>
    union UnionOfOne {
<a title="nl_union_brace"><strong><font color="red">                    █</font></strong></a>
        a1,
        b1,
<a title="nl_ds_struct_enum_cmt"><strong><font color="red">        █</font></strong></a>
        // comment
        c1,
<a title="nl_ds_struct_enum_close_brace"><strong><font color="red">        █</font></strong></a>
    };
<a title="nl_before_access_spec"><strong><font color="red">    █</a><a title="nl_after_func_body_class"> █</font></strong></a>
    private: // same for protected:, signal: or slots: label
<a title="nl_after_access_spec"><strong><font color="red">    █</font></strong></a>
        int ap;
};
<a title="nl_after_class"><strong><font color="red">█</font></strong></a>
<hr>
namespace foo {
<a title="nl_namespace_brace"><strong><font color="red">             █</font></strong></a>
int foo()
{
    if (foo) a++; return;
<a title="nl_after_vbrace_open"><strong><font color="red">        █</a><a title="nl_after_vbrace_close">          █</font></strong></a>
    if (a)
        return;
<a title="nl_after_return"><strong><font color="red">    █</font></strong></a>
l123: <a title="nl_after_label_colon"><strong><font color="red">█</font></strong></a>
    int a = 5;
<a title="nl_before_if"><strong><font color="red">    █</font></strong></a>
    if (a > b) {
        c = 7;
<a title="nl_before_return"><strong><font color="red">    █</font></strong></a>
        return a + b;
    }
    std::for_each(a, b, [] (int& b)->foo{ b+=3; return(b); });
<a title="nl_brace_fparen"><strong><font color="red">                                                            █</font></strong></a>
    QUrl dxOffEagle("http://something/newpage.html?[{\"foo: bar\"}]", QUrl::TolerantMode);
<a title="nl_brace_square"><strong><font color="red">                                                                  █</font></strong></a>
<a title="nl_before_return"><strong><font color="red">    █</font></strong></a>
    return 0;
<a title="nl_return_expr"><strong><font color="red">    █</font></strong></a>
<hr>
/* c1
 *
 */
<a title="nl_comment_func_def"><strong><font color="red">█</font></strong></a>
void b();
<a title="nl_after_func_proto"><strong><font color="red">█</font></strong></a>
void d();
#define LOG_CONTTEXT() \
<a title="nl_multi_line_define"><strong><font color="red">                      █</font></strong></a>
    LOG_FMT(LCONTTEXT  \
            ,"%s:%d set cont_text to '%s'\n"  \
            ,__func__, __LINE__, cmt.cont_text.c_str())
template &lt;class T&gt;
<a title="nl_template_class"><strong><font color="red">█</font></strong></a>
ItemJob<T>::ItemJob(PlatformDependent *internals, const QNetworkRequest &request)
    : GetJob(internals, request)
typedef int ia;
typedef int ib;
<a title="nl_typedef_blk_in"><strong><font color="red">█</font></strong></a>
typedef int ic;
typedef int id;
</pre>
</body>
</html>
